import collections
from enum import Enum

import re

from deepdiff import DeepDiff

import six


class State(Enum):
    ok = 1
    extra_field = 2  # dynamic field
    extra_param = 3
    missing_field = 4
    missing_param = 5
    type_conflict = 6
    param_conflict = 7


class MappingState(object):

    def __init__(self, fieldname, state=State.ok):
        self.fieldname = fieldname
        self.state = state

    def __repr__(self):
        return "%s (%s): %s" % (self.fieldname, self.state.name, self.description)
        # return "%s (%s)" % (self.fieldname, self.state.name)

    @property
    def name(self):
        return 'OK'

    @property
    def description(self):
        return ''


class MappingIssue(MappingState):
    texts = {
        State.extra_field: ('Dynamic Field', 'Field indexed in ES but not declared in the mapper'),
        State.extra_param: ('Extra Param', ('Parameter `{param_name}` defined in ES but not '
                                            'declared in the mapper')),
        State.missing_field: ('Missing Field', ('Field declared in the mapper but not exported '
                                                'to ES yet')),
        State.missing_param: ('Missing Param', ('Parameter {{{param_name}={param_value}}} is '
                                                'declared in the mapper but not exported to '
                                                'ES yet')),
        State.type_conflict: ('Type Conflict', ('Field indexed as `{source_type}` but declared '
                                                'as `{dest_type}`')),
        State.param_conflict: ('Param Conflict', ('Parameter `{param_name}` exported in ES as '
                                                  '`{source_param}` but defined as '
                                                  '`{dest_param}` in the mapper')),
    }

    def __init__(self, issue_type, diff, source, dest, change=None):
        self.diff = diff
        self.chain = self._parse_chain(diff)
        self.source = source
        self.dest = dest
        self.change = change
        self.fieldname = self._parse_fieldname(self.chain)
        self._set_state(issue_type)

    @property
    def name(self):
        return self.texts[self.state][0]

    @property
    def description(self):
        text = self.texts[self.state][1]
        return text.format(**self.__dict__)

    def _parse_chain(self, diff):
        pattern = re.compile(r"(?<=\[)(.*?)(?=\])")
        matches = pattern.findall(diff)
        matches = [m.replace("'", "") for m in matches]
        return matches

    def _parse_fieldname(self, chain):
        return '.'.join(chain[::2])

    def _set_state(self, issue_type):
        if issue_type == 'added':
            if len(self.chain) % 2 == 0:  # param
                self.state = State.extra_param
                self.param_name = self.chain[-1]
            else:  # field
                self.state = State.extra_field
        elif issue_type == 'removed':
            if len(self.chain) % 2 == 0:  # param
                self.state = State.missing_param
                self.param_name = self.chain[-1]
                self.param_value = self._get_value_from_chain(self.source)
            else:  # field
                self.state = State.missing_field
        else:  # 'changed'
            if self.chain[-1] == 'type':
                self.state = State.type_conflict
                self.source_type = self.change['new_value']
                self.dest_type = self.change['old_value']
            elif len(self.chain) % 2 == 0:  # param:
                self.state = State.param_conflict
                self.param_name = self.chain[-1]
                self.source_param = self.change['new_value']
                self.dest_param = self.change['old_value']
            else:
                raise Exception("Unknown mapping state")

    def _get_value_from_chain(self, mapping):
        node = mapping
        for key in self.chain:
            node = node[key]
        return node


class MappingDiffer(object):

    def __init__(self, typename, source, dest):
        self.typename = typename
        self.source = self._normalize_mapping(source)  # mapping generated by a mapper
        self.dest = self._normalize_mapping(dest)  # mapping present in ES

        self.diff()

    def _normalize_mapping(self, mapping):
        "Converts all string-like values of a mapping into the same text type"
        normalized = {}
        for k, v in mapping.iteritems():
            if isinstance(v, dict):
                normalized[k] = self._normalize_mapping(v)
            elif isinstance(v, six.string_types):
                normalized[k] = six.text_type(v)
            else:
                normalized[k] = v
        return normalized

    def diff(self):
        diff = DeepDiff(self.source,
                        self.dest,
                        ignore_order=True)

        states = {}
        fieldnames = [f for f in self._gen_mapping_fieldnames(self.source)]
        for fieldname in sorted(fieldnames):
            states[fieldname] = []

        for chain in diff.get('dictionary_item_added', []):
            # fields -> dynamic fields (fields present in ES but not in the mapper)
            # params -> params present in ES but not in the mapper
            issue = MappingIssue('added', chain, self.source, self.dest)
            states[issue.fieldname] = [issue]

        for chain in diff.get('dictionary_item_removed', []):
            # fields -> new fields added to the mapper, no data with the new field sent to ES yet
            # params -> params newly added or declared in mapper but not sent to ES yet
            issue = MappingIssue('removed', chain, self.source, self.dest)
            if issue.fieldname in fieldnames:
                states[issue.fieldname].append(issue)

        for chain, change in diff.get('values_changed', diff.get('type_changes', {})).items():
            # type -> type conflicts (a type declared in mapper while a different one exists in ES)
            # params -> params modified in mapper but not sent to ES yet
            issue = MappingIssue('changed', chain, self.source, self.dest, change)
            if issue.fieldname in fieldnames:
                states[issue.fieldname].append(issue)

        return self._normalize_states(states)

    def _normalize_states(self, states):
        """
        Perform some useful transformations to the state list:
            - Remove prefix with typename for all state fieldnames
            - Remove superfluous conflicts when there is a type conflict
            - Add `ok` state for fields with no conflicts
        """
        normalized = collections.OrderedDict()
        for fieldname, state_list in states.items():
            # norm_fieldname = fieldname.split('.', 1)[1]
            norm_fieldname = fieldname
            # in case some state is `type_conflict`, we remove the other issues for that field
            # since they will be irrelevant when having a type conflict
            conflicts = [s for s in state_list if s.state == State.type_conflict]
            if conflicts:
                state_list = [conflicts[0]]
            if not state_list:
                normalized[norm_fieldname] = [MappingState(norm_fieldname), ]
            else:
                for state in state_list:
                    state.fieldname = norm_fieldname
                normalized[norm_fieldname] = state_list
        # for fieldname, state in states.items():
        #     state.fieldname = state.fieldname.split('.', 1)[1]
        #     normalized[state.fieldname] = state
        return normalized

    def _gen_mapping_fieldnames(self, mapping, prefix=''):
        fieldnames = []
        new_prefix = (prefix + '.') if prefix else ''
        for fieldname, attrs in mapping.iteritems():
            if 'properties' in attrs.keys():
                # nested object
                nested_fieldnames = self._gen_mapping_fieldnames(attrs['properties'],
                                                                 new_prefix + fieldname)
                for nf in nested_fieldnames:
                    fieldnames.append(nf)
            else:
                fieldnames.append(new_prefix + fieldname)
        return fieldnames
